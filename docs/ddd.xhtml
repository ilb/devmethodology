<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd">
<?xml-stylesheet type="text/xsl" href="/oooxhtml/oooxhtml.xsl"?><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">@page {margin-top:2cm;margin-bottom:2cm;margin-left:2cm;margin-right:2cm;}</style>
    <title>Предметно-ориентированное проектирование</title>
    <meta name="generator" content="oooxhtml/1.4"/>
    <meta name="HeadURL" content="$HeadURL$"/>
  </head>
  <body>
    <div class="container text">
      <h1 id="predmetno-orientirovannoe_proektirovanie">
        <a class="anchor" href="#predmetno-orientirovannoe_proektirovanie">Предметно-ориентированное проектирование</a>
      </h1>
      <h2 id="opredelenie">
        <a class="anchor" href="#opredelenie">Определение</a>
      </h2>
      <p>Проектирование на основе предметной области (Domain Driven Design, DDD) – это объектно- ориентированный подход к проектированию ПО, основанный на предметной области, ее элементах, поведении и отношениях между ними. Целью является создание программных систем, являющихся реализацией лежащей в основе предметной области, путем определения модели предметной области, выраженной на языке специалистов в этой области. Модель предметной области может рассматриваться как каркас, на основании которого будут реализовываться решения.</p>
      <h2 id="celi">
        <a class="anchor" href="#celi">Цели</a>
      </h2>
      <p>DDD — инструмент для обсуждения идей реализации продукта, еще до того как будет написан код. Целью внедрения DDD и принципов SOLID — перестать разрабатывать хрупкий код, ломающийся от каждого изменения. В конечном итоге применение DDD совместно с TDD должно снизить стоимость сопровождения программных продуктов (снизить количество тикетов после релизов, облегчить раннюю диагностику ошибок на этапе разработки).</p>
      <h2 id="stoimost_">
        <a class="anchor" href="#stoimost_">Стоимость</a>
      </h2>
      <p>Предметно-ориентированное программирование вносит определенные издержки на проектирование и реализацию сущностей. Проектировать предметную область следует по принципу необходимого и достаточного усложнения, так любая избыточная сложность усложняет понимание. Хороший пример итеративного усложнения предметной области можно увидеть в главе <a href="https://martinfowler.com/apsupp/accounting.pdf">Accounting Patterns</a> книги <a href="https://martinfowler.com/books/ap.html">Analysis Patterns</a> Мартина Фаулера.</p>
      <h2 id="princip__razrabotki">
        <a class="anchor" href="#princip__razrabotki">Принципы разработки</a>
      </h2>
      <ol>
        <li>
          <p>
            <a href="#SOLID">SOLID</a>
          </p>
        </li>
        <li>
          <p>Сущности должны отражать моделируемую предметную область</p>
        </li>
        <li>
          <p>Ограничивайте изменяемость (<b>final</b> в Java)</p>
        </li>
        <li>
          <p><a href="#cistaj_logika">Чистая логика</a>. Отделяйте бизнес-логику от других слоев приложения (сущности не должны не иметь методов работы с БД, сетью). Сущности могут иметь аннотации (spring, persistance и другие. Наличие аннотаций не является препятствием для того, чтобы создать нужные объекты для теста)</p>
        </li>
        <li>
          <p>Создавайте небольшие сущности для конкретных действий (<b>S</b>ingle Responsibility в Solid). Даже незначительные изменения в больших классах могут быть не тривиальной задачей. Избегайте GOD-объектов с бесконечной функциональностью, они являются копилкой технического долга.</p>
        </li>
        <li>
          <p>Для работы с БД и сетевыми ресурсами используются репозитории, шлюзы и т. п., с возможностью создания заглушек («mocks») для тестирования.</p>
        </li>
      </ol>
      <h2 id="otnosenij">
        <a class="anchor" href="#otnosenij">Отношения</a>
      </h2>
      <p>В методологии DDD предметная область описывается сущностями и их отношениями.</p>
      <p>Рассмотрим 3 основных вида отношений между сущностями: является (<i>is</i>), содержит (<i>has</i>), использует (<i>uses</i>).</p>
      <p>Примеры:</p>
      <p>Автомобиль <i>является</i> транспортным средством.</p>
      <p>Автомобиль <i>содержит</i> двигатель.</p>
      <p>Водитель <i>использует</i> автомобиль (можно употреблять конкретный глагол, например "ведет")</p>
      <h3 id="otnosenie__jvljetsj___is_">
        <a class="anchor" href="#otnosenie__jvljetsj___is_">Отношение «является» (is)</a>
      </h3>
      <p>Отношение «является» показывает общность поведения сущности. Данное отношение должно соответствовать <a href="https://ru.wikipedia.org/wiki/Принцип_подстановки_Барбары_Лисков">принципу подстановки Барбары Лисков (LSP)</a>(буква L в <a href="https://ru.wikipedia.org/wiki/SOLID_(объектно-ориентированное_программирование)">SOLID</a>).</p>
      <p>Данное отношение появляется в предметной области тогда, когда сущности начинают реализовывать общее поведение.</p>
      <p>Примеры</p>
      <p>Автомобиль <i>является</i> транспортным средством.</p>
      <p>Грузовик <i>является</i> транспортным средством.</p>
      <p>Транспортное средство можно <i>завести</i>.</p>
      <p>Принцип LSP означает, что любая функция, использующая метод <i>Транспортное средство.завести()</i> не должна зависеть от того, какого типа конкретный экземпляр транспортного средства передан.</p>
      <h3 id="otnosenie__soderzit___has_">
        <a class="anchor" href="#otnosenie__soderzit___has_">Отношение «содержит» (has)</a>
      </h3>
      <p>Отношение «содержит» определяет состав сущностей.</p>
      <p>В описании сущности следует приводить не все ее свойства, а только существенные в данной ситуации. Описывая состав сущности, мы мысленно «разбираем» ее на части. При этом, как правило, используется такой приём: сначала называется небольшое число крупных частей, затем каждая из них «разбирается» на части поменьше и так далее.</p>
      <h3 id="otnosenie__ispol_zuet___uses_">
        <a class="anchor" href="#otnosenie__ispol_zuet___uses_">Отношение «использует» (uses)</a>
      </h3>
      <p>Отношение «использует» описывает случай, когда сущности не связаны напрямую, а используется в качестве аргументов.</p>
      <h2 id="SOLID">
        <a class="anchor" href="#SOLID">SOLID</a>
      </h2>
      <p>SOLID - это аббревиатура от набора из пяти принципов разработки программного обеспечения, соблюдении которых призвано помочь разработчикам создавать гибкий и чистый код, не зависимо от языка программирования.</p>
      <p>Основная идея принципов SOLID - «разделение». Объекты, модули, функции в программе должны быть свободно соединены таким образом , чтобы предотвратить распространение изменения в одном месте на другие места программы. Причина, по которой это желательно, заключается в том, что слабосвязанные объекты проще в обслуживании, они более гибкие и более мобильные.</p>
      <h3 id="Single-responsibility_principle__SRP_">
        <a class="anchor" href="#Single-responsibility_principle__SRP_">Single-responsibility principle (SRP)</a>
      </h3>
      <p>Классы должны иметь единую ответственность и, таким образом, только один повод для изменения.</p>
      <p>Изолируя части функциональности в отдельных классах / модулях, SRP помогает нам защититься от ненужного связывания «ответственностей». Если реализация одной «ответственности» изменяется, SRP предотвращает влияние изменения на другие обязанности. Таким образом не изменяющийся код не ломается, его тесты «не проваливаются» от изменений.</p>
      <h3 id="Open–closed_principle">
        <a class="anchor" href="#Open–closed_principle">Open–closed principle (OCP)</a>
      </h3>
      <p>Классы и другие объекты должны быть открыты для расширения , но закрыты для модификации.</p>
      <p>Данный принцип напрямую связан с полиморфизмом. </p>
      <ul>
        <li>
          <p>Новые реализации логики должны быть реализованы через новые классы, не затрагивая старые, через наследование и полиморфизм.</p>
        </li>
        <li>
          <p>Внутренние детали реализации должны быть скрыты от «пользователя» интерфейса.</p>
        </li>
      </ul>
      <p>Ключевым способом реализации OCP является «кодирование под абстракции», а не конкретные реализации.</p>
      <p style="font-style:italic;">Роберт C. Мартин, создатель и главный проповедник SOLID, считает Бертрана Мейера создателем OCP. В своей книге 1988 года « Конструирование объектно-ориентированного программного обеспечения» Мейер описывает необходимость разработки гибких систем, которые могут адаптироваться к изменениям без сбоев. Для этого Мейер выступает за проектирование систем, в которых объекты (классы, модули, функции и т. Д.) «Открыты для расширения, но закрыты для модификации».</p>
      <h3 id="Liskov_Substitution_Principle">
        <a class="anchor" href="#Liskov_Substitution_Principle">Liskov Substitution Principle (LSP)</a>
      </h3>
      <p>Подтип объекта должен быть взаимозаменяемым с его родительским типом, если это касается любых функций, которые полагаются на родительский объект</p>
      <p>Подтипы не должны нарушать контракты, установленные их родительскими типами.</p>
      <p>Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.</p>
      <p>Несоблюдение LSP быстро вызывает проблемы по мере расширения кодовой базы. Без соблюдения LSP изменения в программе могут иметь неожиданные последствия связанные с изменением ранее работавшего кода. С другой стороны, следование LSP позволяет легко расширять поведение программы, поскольку подклассы могут быть вставлены в рабочий код, не вызывая побочных эффектов.</p>
      <p style="font-style:italic;">В объектно-ориентированном дизайне распространенной техникой создания объектов с одинаковым поведением является использование супертипов и подтипов. Супертип определяется с помощью некоторого набора характеристик, которые затем наследуются всеми его подтипами. В свою очередь, подтипы могут затем переопределить реализацию некоторого поведения супертипа, что позволяет дифференцировать поведение посредством полиморфизма. Это чрезвычайно мощная техника; однако возникает вопрос, что точно делает один объект подтипом другого. Достаточно ли одного объекта унаследовать от другого? В 1987 году Барбара Лисков предложила ответ на этот вопрос, утверждая, что объект следует рассматривать как подтип другого объекта, только если он взаимозаменяем со своим родительским объектом в отношении любой взаимодействующей функции.</p>
      <h3 id="Interface_Segregation_Principl">
        <a class="anchor" href="#Interface_Segregation_Principl">Interface Segregation Principle (ISP)</a>
      </h3>
      <p>Программные сущности не должны зависеть от методов, которые они не используют.</p>
      <p>Целью ISP является защита от так называемого «загрязнения интерфейса», когда объект реализует интерфейс, который гарантирует поведение, выходящее за рамки того, что требуется конкретному объекту. </p>
      <p>LSP и OCP призывают нас кодировать под абстракции, под интерфейсы, где интерфейс является своего рода «контрактом». Однако что происходит, когда вы вынуждены создать объект, которому на самом деле не нужны все поведения, описанные в его интерфейсе?</p>
      <p>Поскольку интерфейс является контрактом, вам придется определять поведение, которое фактически бесполезно. В просторечии это известно как «загрязнение интерфейса», потому что класс может загрязняться поведением, которое ему не нужно. Что еще хуже, это загрязнение распространяется на любые подклассы загрязненного суперкласса. Это особенно «коварный» вид связывания, потому что он создает зависимости, которые <i>не делают ничего даже незначительно полезного</i>.</p>
      <p style="font-style:italic;">В рамках своих принципов SOLID Роберт C. Мартин предложил решение этой проблемы, которое он назвал принципом разделения интерфейсов (ISP). Мартин утверждал, что загрязнение интерфейса было в первую очередь результатом «толстых интерфейсов», то есть интерфейсов с большим количеством предписанных методов. Чтобы противостоять эффектам «жирных» интерфейсов, Мартин определил ISP следующим образом:</p>
      <p style="font-style:italic;font-weight:bold;">Клиенты не должны зависеть от интерфейсов, которые они не используют.</p>
      <p style="font-style:italic;">Мартин выступает за использование так называемых «ролевых интерфейсов», которые представляют собой небольшие интерфейсы, содержащие только методы, которые представляют интерес для объектов, которые их используют. Поэтому толстый интерфейс можно разбить на более мелкие ролевые интерфейсы, которые гарантируют определенное связанное поведение. </p>
      <h3 id="Dependency_inversion_principle">
        <a class="anchor" href="#Dependency_inversion_principle">Dependency inversion principle (DIP)</a>
      </h3>
      <p>Как высокоуровневые, так и низкоуровневые модули должны зависеть от взаимных абстракций, а не напрямую друг от друга.</p>
      <p>Использование DIP улучшает гибкость и удобство сопровождения программы, так как устраивает зависимости таким образом, чтобы уменьшить влияние изменений в одном месте на другое.</p>
      <p>Для того, чтобы эффективно применять DIP, вы должны понять абстракции вашей программы и использовать их для построения контрактов между сущостями, вместо деталей реализации.</p>
      <h2 id="cistaj_logika">
        <a class="anchor" href="#cistaj_logika">Чистая логика</a>
      </h2>
      <p><a href="https://ru.wikipedia.org/wiki/Чистота_функции">Чистая функция</a> обладает следующими свойствами:</p>
      <ol>
        <li>
          <p>является детерминированной;</p>
        </li>
        <li>
          <p>не обладает побочными эффектами (не работает с глобальными переменными, базами данных, файлами, сетью).</p>
        </li>
      </ol>
      <p>Вы должны моделировать большую часть вашей логики чистыми функциями (классами) для того, чтобы она могла быть повторно используемой и тестируемой.</p>
      <p>Так как результат чистой функции зависит только от входных аргументов, и не зависит от состояния всей остальной системы, она требуем меньше тестов для проверки. Поскольку она не содержит побочных эффектов, контекст для нее проще подготовить. Вы просто вызываете конструктор класса или функцию с нужными данными и проверяете результат.</p>
      <h2 id="sloi_prilozenij">
        <a class="anchor" href="#sloi_prilozenij">Слои приложения</a>
      </h2>
      <h3 id="sloj_predmetnoj_oblasti">
        <a class="anchor" href="#sloj_predmetnoj_oblasti">Слой предметной области</a>
      </h3>
      <p>Создание слоя предметной области является главной целью создания приложения. Слой состоит из небольших сущностей, реализующих бизнес-логику. Бизнес-логика - это моделирование объектов и процессов предметной области (т.е. реального мира). Бизнес-логика может включать в себя:</p>
      <ol>
        <li>
          <p>Как данные преобразовываются или вычисляются. Например, вычисление суммы комиссионных или налога.</p>
        </li>
        <li>
          <p>Как данные передаются людям или программным компонентам (описывают бизнес-процесс)</p>
        </li>
      </ol>
      <p>В данном слое располагается «структурированная» бизнес-логика, сформированная из «сущностей». В данном слое вы разбиваете комплексную логику на отдельные «классы»-«функции». </p>
      <p>В качестве аналогии можно привести любой пример сложной системы из реальной жизни. Например, двигатель автомобиля передает вращение генератору, но они не объединяются в единый аггрегат. Они «разрабатываются» и «тестируются» независимо, после чего соединяются в единую бизнес-логику «автомобиль», взаимодействуя друг с другом через «интерфейс».</p>
      <p>Точно так же внутри приложения появляются сущности, взаимодействующие друг с другом, отвечающие за свою «зону ответственности». Например, заявка на кредит может взаимодействовать с продуктовой корзиной. Очевидно, что не всякая заявка подходит под условия карты кредитных продуктов в виду ограничений. Однако то, как обрабатывать данные ограничения, не может быть реализовано единой логикой карты кредитных продуктов. В этом случае мы приходим к взаимодействию сущностей, отвечающих с одной стороны за заявку, с другой стороны за кредитный продукт.</p>
      <p>Другими словами, сущности — это «игроки», их взаимодействие - «правила игры». а структуры данных, которыми они обмениваются - «мячи». Описав все это, вы получите слой предметной области.</p>
      <p>В зависимости от специфики приложения слой предметной области может быть, а может и не быть связанным со <a href="#sloj_hranenij">слоем хранения</a> и <a href="#sloj_slyzov">слооем шлюзов</a>.</p>
      <p>Для тестирования слоя предметной области применяются юнит-тесты.</p>
      <h3 id="sloj_sluzb">
        <a class="anchor" href="#sloj_sluzb">Слой служб</a>
      </h3>
      <p>При анализе кода часто можно увидеть разбухшие доменные модели с огромным числом методов, что, как правило, объясняется посторонними обязанностями класса. Для того, чтобы избежать появления классов с множествами обязанностей следует интерфейсы доступа к домену.</p>
      <p>Приводя аналог из «реальной жизни», мы можем снова рассмотреть систему «автомобиль». Вы, как водитель, не собираете автомобиль каждый раз из его агрегатов, чтобы поехать на нем. Вы даже можете не догадываться о том, что у него «под капотом». Вы просто пользуетесь службами «руля», «газа», «тормоза» и т.д.</p>
      <p>
        <cite>Слой служб устанавливает множество доступных действий и координирует отклик приложения на каждое действие. - “Patterns of Enterprise Application Architecture”</cite>
      </p>
      <p>Из книги “Patterns of Enterprise Application Architecture” by Martin Fowler, Randy Stafford.</p>
      <p>
        <cite>Двумя базовыми вариантами реализации слоя служб являются создание интерфейса доступа к домену (domain facade) и конструирование сценария операции (operation script). При использовании подхода, связанного с интерфейсом доступа к домену, слой служб реализуется как набор “тонких” интерфейсов, размещенных “поверх” модели предметной области. В классах, реализующих интерфейсы, никакая бизнес-логика отражения не находит — она сосредоточена исключительно в контексте модели предметной области. Тонкие интерфейсы устанавливают границы и определяют множество операций, посредством которых клиентские слои взаимодействуют с приложением, обнаруживая тем самым характерные свойства слоя служб.</cite>
      </p>
      <p>
        <cite>Создавая сценарий операции, вы реализуете слой служб как множество более “толстых” классов, которые непосредственно воплощают в себе логику приложения, но за бизнес-логикой обращаются к классам домена. Операции, предоставляемые клиентам слоя служб, реализуются в виде сценариев, создаваемых группами в контексте классов, каждый из которых определяет некоторый фрагмент соответствующей логики. Подобные классы, расширяющие супертип слоя (Layer Supertype, 491) и уточняющие объявленные в нем абстрактные характеристики поведения и сферы ответственности, формируют “службы” приложения (в названиях служебных типов принято употреблять суффикс “Service”). Слой служб и заключает в себе эти прикладные классы.</cite>
      </p>
      <h3 id="sloj_hranenij">
        <a class="anchor" href="#sloj_hranenij">Слой хранения</a>
      </h3>
      <p>Репозитории, струкуры доступа к данным.</p>
      <h3 id="sloj_slyzov">
        <a class="anchor" href="#sloj_slyzov">Слой шлюзов</a>
      </h3>
      <p>Шлюзы, адаптеры к внешним системам.</p>
      <h3 id="sloj_kontrollerov">
        <a class="anchor" href="#sloj_kontrollerov">Слой контроллеров</a>
      </h3>
      <p>Слой контроллеров должен быть максимально тонким. Вы не должны обращаться к базе данных или реализовывать бизнес-логику в контроллере.</p>
      <p>Перечень задач контроллера</p>
      <ol>
        <li>
          <p>Принять веб-запрос</p>
        </li>
        <li>
          <p>Провалидировать запрос по схеме</p>
        </li>
        <li>
          <p>Десериализовать запрос</p>
        </li>
        <li>
          <p>Вызвать вариант использования, передав на вход структуру данных, получить ответную структуру данных</p>
        </li>
        <li>
          <p>Сериализовать ответную структуру данных и передать в транспортный слой, установив требуемые заголовки</p>
        </li>
      </ol>
      <h2 id="vnedrenie_zavisimostej">
        <a class="anchor" href="#vnedrenie_zavisimostej">Внедрение зависимостей</a>
      </h2>
      <p>Используйте инверсию управления в виде “Внедрения зависимостей” <a href="https://martinfowler.com/articles/injection.html">Dependency Injection</a> (DI). Внедрение зависимостей облегчает тестирование и параллельную разработку ПО (например, в случаях, когда вызываемые компоненты еще не готовы, для них создаются заглушки)</p>
      <p>
        <cite>Истинное внедрение зависимостей идет еще на один шаг вперед. Класс не предпринимает непосредственных действий по разрешению своих зависимостей; он остается абсолютно пассивным. Вместо этого он предоставляет set-методы и/или аргументы конструктора, используемые для внедрения зависимостей. В процессе конструирования контейнер DI создает экземпляры необходимых объектов (обычно по требованию) и использует аргументы конструктора или set-методы для скрепления зависимостей. Фактически используемые зависимые объекты задаются в конфигурационном файле или на программном уровне в специализированном конструирующем модуле.</cite>
      </p>
      <h3 id="preimusestva_vnedrenij_zavisimostej">
        <a class="anchor" href="#preimusestva_vnedrenij_zavisimostej">
          <cite>Преимущества внедрения зависимостей</cite>
        </a>
      </h3>
      <h4 id="podderzivaem_j_kod">
        <a class="anchor" href="#podderzivaem_j_kod">
          <cite>Поддерживаемый код</cite>
        </a>
      </h4>
      <p>
        <cite>Простые, автономные классы легче исправить, чем сложные, тесно связанные классы.</cite>
      </p>
      <p>
        <cite>Если ваши классы слабо связаны и следуют принципу единой ответственности, ваш код будет легче поддерживать.</cite>
      </p>
      <p>
        <cite/>
      </p>
      <p>
        <cite>Поддерживаемый код имеет более низкую общую стоимость владения. Затраты на обслуживание часто превышают затраты на создание кода в первую очередь, поэтому все, что повышает удобство сопровождения вашего кода — хорошо.</cite>
      </p>
      <h4 id="testiruemost_">
        <a class="anchor" href="#testiruemost_">
          <cite>Тестируемость</cite>
        </a>
      </h4>
      <p>
        <cite>Код, который легко проверить, тестируется лучше. Больше тестирования означает более высокое качество и надежность кода.</cite>
      </p>
      <p>
        <cite>Слабо связанные классы с одной ответственностью очень просты для модульного тестирования.</cite>
      </p>
      <p>
        <cite>Если вы передаете зависимости в классы, создать дублирующую тестовую реализацию будет просто. Если зависимости жестко запрограммированы, невозможно создать тестовые варианты для них.</cite>
      </p>
      <h4 id="citaemost_">
        <a class="anchor" href="#citaemost_">
          <cite>Читаемость</cite>
        </a>
      </h4>
      <p>
        <cite>Код с внедрением зависимостей более читаем. Благодаря функциональной декомпозиции код не перегружен ненужными деталями. Более читаемый код более удобен в сопровождении</cite>
      </p>
      <h4 id="gibkost_">
        <a class="anchor" href="#gibkost_">
          <cite>Гибкость</cite>
        </a>
      </h4>
      <p>
        <cite>Программное обеспечение должно быть способным изменяться и адаптироваться к новым требованиям. Слабосвязанный код является гибким и может адаптироваться к этим изменениям.</cite>
      </p>
      <p>Небольшие классы, которые делают что-то одно, легче собрать и использовать повторно в разных ситуациях.</p>
      <p>Маленькие классы похожи на Lego - их можно легко соединить, чтобы создать множество вариантов использования. Возможность повторного использования кода экономит время и деньги.</p>
      <h4 id="rassirjemost_">
        <a class="anchor" href="#rassirjemost_">Расширяемость</a>
      </h4>
      <p>Кодовая база приложения никогда не остается статичной, и вам, скорее всего, придется добавлять новые функции по мере роста вашей кодовой базы и возникновения новых требований. Расширяемый код отвечает этим требованиям.</p>
      <p>Небольшие, гибкие классы можно легко расширять либо наследованием, либо композицией.</p>
      <p>Код, использующий внедрение зависимостей, приводит к более расширяемой структуре классов. Полагаясь на абстракции вместо реализаций, приложение может легко варьировать нужную реализацию.</p>
      <p>Когда вы кодируете с использованием абстракций, вы можете положиться на то, что всегда возможна лучшая реализация того, что вы делаете и эта замена не будет стоить вам дорого.</p>
      <h4 id="komandnaj_razrabotka">
        <a class="anchor" href="#komandnaj_razrabotka">
          <cite>Командная разработка</cite>
        </a>
      </h4>
      <p>Внедрение зависимостей требует от вас кодирования абстракций, а не реализаций.</p>
      <p>Если вы работаете в команде, внедрение зависимостей облегчит развитие команды. (Даже если вы работаете в одиночку, ваша работа, вероятно, будет передана кому-то в будущем.)</p>
      <p>Вы можете определить абстракции перед выполнением реализаций. Затем каждый разработчик может написать свой код, используя абстракции, еще до того, как будут написаны реализации.</p>
      <p>
        <cite>Кроме того, поскольку код слабо связан, эти реализации не будут полагаться друг на друга, и поэтому их легко разделить между разработчиками</cite>
      </p>
      <h3 id="preimusestva_kodirovanij_s_interfejsami">
        <a class="anchor" href="#preimusestva_kodirovanij_s_interfejsami">
          <cite>Преимущества кодирования с интерфейсами</cite>
        </a>
      </h3>
      <h4 id="kodirovanie_pod_abstrakcii">
        <a class="anchor" href="#kodirovanie_pod_abstrakcii">
          <cite>Кодирование под абстракции</cite>
        </a>
      </h4>
      <p>Вы должны проектировать ваш код на столько свободным и слабо связанным, на сколько это возможно. Используя интерфейсы, вы описываете части программы как блоки лего. <i>Определяя количество "выступов" с той и другой стороны, вы гарантируете то, что реализация интерфейса будет подходящей.</i></p>
      <p>Если вы никогда не соединяетесь ни с чем, кроме интерфейсов, то это настолько слабосвязанно, насколько это возможно.</p>
      <h4 id="podklycaem_e_realizacii">
        <a class="anchor" href="#podklycaem_e_realizacii">Подключаемые реализации</a>
      </h4>
      <p>Классы должны разрабатываться и тестироваться изолированно с небольшим количеством внешних зависимостей или вообще без них. Разумеется, основная часть кода не может работать изолированно. Код всегда зависит от чего-то. Если ваш код зависит от интерфейса, а не от конкретной реализации, вы легко сможете подменить зависимость на этапе тестирования. Так же вы можете легко подключать различные реализации во время выполнения программы, реализующие различные сценарии работы.</p>
      <p>В будущем вы всегда можете найти лучшую реализацию интерфейса и подменить реализацию. Это позволит вам в том числе на ранних этапах разработки приложения создавать более простые реализации, которые можно будет улучшить в последствии.</p>
      <h4 id="mezmodul_naj_svjz_">
        <a class="anchor" href="#mezmodul_naj_svjz_">Межмодульная связь</a>
      </h4>
      <p>Интерфейсы позволяют организовать распределенную работу в командах. Различные модули приложения могут быть созданы различными разработчиками или командами. Отдавая реализацию модуля другой команде или разработчику, вы согласуете интерфейс и можете в даже не "копаться" в деталях реализации. </p>
      <h4 id="testiruem_j_kod">
        <a class="anchor" href="#testiruem_j_kod">Тестируемый код</a>
      </h4>
      <p>Интерфейсы делают ваш код тестируемым. Как отмечалось выше, поскольку вы используете интерфейсы, вы можете легко заменить любую реализацию, какую захотите. Что если вы тестируете и не хотите подключаться к производственной базе данных? Вы можете предоставить фиктивную реализацию для интерфейса подключения к базе данных - такую, которая только притворяется базой данных и возвращает консервированные данные, - и теперь вы можете тестировать свой код изолированно, фактически не подключаясь к базе данных</p>
      <h4 id="sablon_">
        <a class="anchor" href="#sablon_">Шаблоны</a>
      </h4>
      <p>Интерфейсы облегчают реализацию шаблонов проектирования и позволяют делают такие вещи, как Dependency Injection . Большинство шаблонов и практик, включая платформы внедрения зависимостей, доступны благодаря мощным и гибким интерфейсам. Шаблоны и архитектуры разработки, такие как Model-View-Controller (MVC) и Model-View-ViewModel (MVVM), намного проще реализовать и использовать при проектировании с интерфейсами.</p>
      <h2 id="instrument__proektrovanij">
        <a class="anchor" href="#instrument__proektrovanij">Инструменты проектрования</a>
      </h2>
      <ol>
        <li>
          <p><a href="http://plantuml.com/ru/">PlantUML</a>, <a href="http://plugins.netbeans.org/plugin/49069/plantuml">плагин NetBeans</a> и <a href="https://docs.ilb.ru/plantuml/">web-сервер для рисования диаграмм в браузере</a></p>
        </li>
      </ol>
    </div>
  </body>
</html>
